# Devigny Theory of Operation

A Devigny user is an entity with knowledge of a secret key. A claim is
a Pedersen commitment to that secret key. A verification is both a
proof of knowledge of the key in a claim, as well as a proof that all
claims commit to the same key.

## Pedersen Commitments

Devigny uses the secp256r1 elliptic curve variant of a Pedersen
commitment, Z:

```
Z = x*G + r*H
```

Where `x` is known as a message and is our secret key, and `r` is a
random blinding factor. `G` and `H` are known public points (see NUMS
section below). The `(x, r)` pair is known as the opening.

## Proof Book

A Devigny proof book consists of:

1. a proof of knowledge of opening for a root commitment which
   contains as its message the secret key.
2. a commitment for each account, C, and proof that C has the same
   message as the root.

By transitivity, each account commitment must be derived from the same
secret key.

### Non-Interactive Proof of Knowledge of Opening

When generating the proof book, we first prove knowledge of the root
commitment's opening.

```
let x, r = the opening
let Z = the commitment x*G + r*H
let t1 = a random 256 bit integer
let t2 = a different random 256 bit integer

compute T = a commitment, t1*G + t2*H
compute c = a challenge, 256 bit integer HASH(Z || T)
compute s1 = t1 + c*x
compute s2 = t2 + c*r

discard t1 and t2

record (Z, T, s1, s2) in the proof book as the root
```

`Z` is a commitment to our secret key. `T` is derived from two random
values, `t1` and `t2`, and is thus unrelated to `Z`. `s1` and `s2` are
derived from the discarded random values, and thus are blind to `x`
and `r` respectively. Note that even with knowledge of `c`, an
attacker still would not be able to compute either the `t` values or
the opening.

Verification proceeds as follows:

```
read (Z, T, s1, s2) from the proof book

compute c = the same challenge, HASH(Z || T)
check that:
  s1*G + s2*H == T + c*Z
```

The proof that this relationship holds is straightforward:

```
s1*G + s2*H = (t1 + c*x)*G + (t2 + c*r)*H
            = t1*G + c*x*G + t2*H + c*r*H
            = t1*G + t2*H + c*(x*G + r*H)
            = T + c*Z
```

### Non-Interactive Zero Knowledge Proof of Message Equality

A similar strategy can be used to prove message equality between the
root and an account commitment.

```
let P = the root commitment (with x = message, and Pr = blinding factor)
let Q = the account commitment (x = message, and Qr = blinding factor)
let t1 = a random 256 bit integer
let t2 = a different random 256 bit integer
let t3 = yet another random 256 bit integer
let binding = the unique URI bound to this commitment

compute TP = the commitment, t1*G + t2*H
compute TQ = the commitment, t1*G + t3*H
compute c = HASH(P || TP || Q || TQ || binding)
compute s1 = t1 + c*x
compute s2 = t2 + c*Pr
compute s3 = t3 + c*Qr

discard t1, t2, t3

record (P, Q, TP, TQ, s1, s2, s3) to the proof book
```

Verification proceeds as follows:

```
read (P, Q, TP, TQ, s1, s2, s3) from the proof book

compute c = the same challenge, HASH(P || TP || Q || TQ || binding)
check that:
  s1*G + s2*H == TP + c*P
  s1*G + s3*H == TQ + c*Q
```

The proof these equations hold is similar to that of the knowledge of
opening:

```
s1*G + s2*H = (t1 + c*x)*G + (t2 + c*Pr)*H
            = t1*G + c*x*G + t2*H + c*Pr*H
            = t1*G + t2*H + c*x*G + c*Pr*H
            = TP + c*P

s1*G + s3*H = (t1 + c*x)*G + (t3 + c*Qr)*H
            = t1*G + c*x*G + t3*H + c*Qr*H
            = t1*G + t3*H + c*x*G + c*Qr*H
            = TQ + c*Q
```

Can an impostor fake a proof bound to a different URI?

The impostor has no knowledge of the opening, nor `t1`, `t2`, and `t3`
values generated by the user, but _does_ know `(P, Q, TP, TQ, s1, s2,
s3)`. To fake a proof, the impostor would need to generate a new set
of `(TP', TQ', s1', s2', s3')` such that `c'` is `HASH(P || TP' || Q || TQ'
|| binding')` where the binding is the fake URI _and_ that the verification
equations `s1'*G + s2'*H = TP' + c'*P` and `s1*G + s3*H = TQ + c*Q` hold.

Performing such a feat implies that the imposter knows:

```
s1 = t1 + c*x

which implies

x = (s1' - t1') / c'
```

However this would violate the assumption that the imposter does not
know `x`.

## NUMS (Nothing Up My Sleeve)

In order for the security of the scheme to hold, there must not be a
known relationship between G and H. The following algorithm is used to
select G and H.

1. Append a counter to some string S.
2. Let x = the sha256 has of S
3. Solve for y on the secp256r1 curve.
4. If the resulting (x, y) point is not on the curve, increment the
   counter and go back to step 1.

See `nums.py` for the code used to generate G and H.

Devigny's public G is the point that corresponds to `NUMS("devigny")`
and H is `NUMS("acheron")`. The Acheron is the ship piloted by the
French captain de Vigny in the 2003 film version of _Master and
Commander_.

## Notes

Some useful links to understand Pedersen commitments and zero knowledge proofs:

- Very good treatment of ZK, commitments, and bulletproofs:
  https://moodle.unige.ch/pluginfile.php/309148/mod_folder/content/0/From%20zero%20knowledge%20to%20bulletproofs%20-%20Gibson.pdf?forcedownload=1

- Pedersen commitments, reviewed in Bulletproof protocols:
  https://tlu.tarilabs.com/cryptography/the-bulletproof-protocols#pedersen-commitments-and-elliptic-curve-pedersen-commitments
